---
title: JavaScript中的内存管理与常见的内存泄漏处理方法-笔记
date: 2017-09-18 18:55:43
updated: 2017-09-22
tags:
- JavaScript
- Memory
---

{% blockquote Alexander Zlatkov 
https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec %}
阅读《How JavaScript works: memory management + how to handle 4 common memory leaks》文章笔记
{% endblockquote %}

常见的编程语言，例如C/C++这些低级编程语言是由编程人员自己手动管理内存的，例如常见的内存分配```malloc```和内存释放```free```。程序员可以使用这些语法来向操作系统请求或者释放掉内存。

<!--more-->

其他高级编程语言，例如Java/JavaScript，在语言层面上做了自动的内存管理，无须程序编写人员手动的编写内存管理。JavaScript中有个单独的垃圾回收进程，在变量，对象，字符串等呗创建时动态的分配内存，并且在这些变量，对象或字符串不再被使用之后释放他们。自动的过程简化了内存管理的过程，使得程序员不需要过分关心内存的分配情况，同时避免了不靠谱的内存操作。但是同时很多人完全忽略掉了内存管理这个问题。

内存管理一直是一大难题，有一本关于垃圾回收的书很有名，有空可以阅读下：
{% blockquote [日] 中村成洋，相川光 著；丁灵 译；竹内郁雄 校 https://item.jd.com/12010270.html%}
《垃圾回收的算法与实现》
{% endblockquote %}

回到正题，自动内存管理并不是很智能的，它可以handle住大多数的情况，但是总有些意料之外的问题，并且这些意料之外的问题大多是由于编写人员部署需内存机制导致的。

### 内存生命周期

无论哪种编程语言，都有一个类似生命周期过程：

内存分配 -> 内存使用 -> 内存释放，

三个生命周期的过程大概如下：

1. 内存分配： 操作系统分配内存空间出来给编程语言使用，如上所述，低级语言如C/C++，需要手动的申请内存，而在高级语言中，一切都是自动的。
2. 内存使用： 这个阶段是编程语言运行时使用内存的阶段，运行时使用这些内存进行读写操作
3. 内存释放： 当不再需要某些内存对象时，便可以释放它，这一部分内存空间会被操作系统回收，并可用做下次内存分配。

### 什么是内存

硬件层面上，内存是大量的晶体管构成的组合体，多个晶体管组合成flip flops，每个flip flops由一个特殊的标识符做索引，用于寻址，从而可以内存寻址，并且可以复写或者读取flip flops上的内容。

一个晶体管可以存储1bit，8个bit为一个byte，根据不同的操作系统和硬件平台，16/32个bit可以组成一个word。在一个程序由开始到结束的过程中，几乎所有的东西都需要和内存相关。所有的变量和程序中使用的数据需要存储到内存中，所有的程序代码。包括操作系统本身也需要装载至系统中。

当编译器编译代码时，编译器会提前估算出程序中所有的原始数据类型所需要的内存容量，然后固定数量的内存空间会被分配给程序，这些内存空间通常称为栈空间。栈空间用于存放上面计算所需的所有的原始数据类型。之所以称之为栈空间，是因为变量的进出遵循FIFO原则。

{% codeblock lang:js%}
int n; // 4 bytes
int x[4]; // 4 * 4 bytes
double m; // 8 bytes
{% endcodeblock %}

编译器可以简单的确定总共需要 4 + 4 * 4 + 8 = 28 bytes。

{% blockquote %}
每一个int型变量或double型变量占用几个字节和操作系统，硬件平台相关，实际情况应具体情况具体分析
{% endblockquote %}

编译器请求在栈空间分配特定数量的内存空间，用于存放变量。在上面的示例代码中，编译器明确的知道它所需要的内存空间的大小和地址。无论我们对变量x进行何种操作， 基本上都会被翻译为对内存空间地址为xxxx的内存进行操作。

每个变量所代表的都是一个内存地址，内存地址指向的内存空间会存储变量对应的值。我们可以把变量当做一个地址，专门用于寻找对应内存地址的内存空间所储存的数据。

当一个函数调用另外一个函数的时候，每一个函数被调用时都会获得自身的栈块，栈块保存着这个函数自身的所有本地变量和一个程序计数器，程序计数器保存着执行器的位置。当函数运行结束后，对应的内存块会被释放，用作其他用途。

### 动态内存分配

由上所述，栈空间一般会在编译时申请并能够计算出大致的所需要的内存空间大小。然后更多的时候，根本无法在编译时确定所需要的内存空间大小。
例如读取用户数据，数据大小无法确定，或者读取文件，同样也无法确定。

{% codeblock lang:js%}
let n = readDataFromUser();
// some async input event functions
let a = new Array(n);
{% endcodeblock%}

编译时，编译器并不知道需要多大的内存空间供给数组```a```使用。因为数组```a```的大小只能够在运行时确定。因此这部分只能够在运行时确定分配的内存大小，不能够在栈空间上进行分配。只能够在运行时，从一个名为堆空间的地方分配而来。

关于内存的静态分配和动态分配主要有以下不同之处

静态分配 | 动态分配
---|---
内存空间大小必须在编译时确定 | 需要的内存空间的大小在编译时可能无法确定
编译时进行内存分配，向操作系统申请空间 | 运行时申请内存
内存空间分配给栈空间 | 内存分配给堆空间
FILO 序列 | 无特定的进出序列

{% blockquote %}
关于内存的动态分配需要关注内存指针的内容，具体的话会另开博客阐述
{% endblockquote %}

### JS中内存分配

以上阐述的大多是概念性的内容，适用于大多数的解释型语言。接下来具体讲述下JS中详细的内存分配机制

JS将内存分配的任务从开发者的身上转移到自身，由JS自己负责内存的分配。

{% codeblock lang:js %}
let n  = 111; // 分配内存储存数字
let s = 'ssssss'; // 分配内存存储字符串
let o = {
    a: 1,
    b: 2
}; // 分配内存给对象和对象内的值
let arr = [1, 2, nul, 'sgsg']; // 同对象的内存分配，给数组和数组内的值分配内存空间
function foo(a) {
    return a + 1111;
} // function同为对象，只是callable，分配策略同上
document.body.addEventListener('click', function(event) {
    console.log('event handler');
}, false); // 同上

let d = new Date(); // 分配Date对象
let ele = document.createElement('div'); // 分配DOM对象

let str1 = 'asdfqweqwe';
let str2 = str1.substr(0, 3); // JS中字符串是不可变对象，一般来说会重新创建一个新的String对象然后赋值给`str2`
// 或者JS引擎会执行优化，只存储`str1`的`0-3`位置上的字符的地址。
{% endcodeblock %}

### JS中内存的使用

使用内存即从内存中读取数据或者写数据。可以通过变量名赋值取值，或者函数中调用，传参等实现

### JS中内存释放

内存释放一直是一大难题，内存管理中大部分问题都出现在这个阶段。

一般的内存释放策略都是一旦这部分内存上的数据不再被使用了或者此块内存不再被使用了，就可以释放该块内存。然而最难确定的是如何确定被分配的内存是否真的不再会被使用了。自动内存管理的一大弊端就在于此，尽量C/C++手动管理内存很麻烦，也很容易出错，但是如果开发者清楚何时何地申请或者释放内存，那么就是有优势的。而自动内存管理无法真的确定一块内存是否真的不再需要了。

高级语言一般包含一个嵌入的程序-垃圾回收器。垃圾回收器的职责是跟踪所有的内存分配和使用，以便于确定一块被分配的内存是否不再被需要使用了，如果是，那么就释放这块内存。

然而垃圾回收过程只能做到不完美的效果，因为一块内存是否被需要，是一个垃圾回收器难以决定的问题。

大多数的垃圾回收器退而求其次，既然不存在一个算法能否真的确定一块内存是否真的被需要，那么可以追踪一个内存是否可以被访问，例如一旦运行进程跳出了某个变量的作用域，那么这个变量就不再可访问了，那么就可以释放这部分内存。

### 垃圾回收

接下来介绍几种常见的垃圾回收算法和优缺点：

#### 内存引用

todo: 待完善